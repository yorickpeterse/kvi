import kvi.mem (Allocator, BLOCK_SIZE, Block)
import std.io (Buffer, Error, Read)
import std.test (Tests)

type inline ErrorReader {}

impl Read for ErrorReader {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    Result.Error(Error.ConnectionAborted)
  }
}

fn pub tests(t: mut Tests) {
  t.ok('Block.allocate with a fragmented block', fn (t) {
    let blk = Block.new
    let buf = Buffer.new('abc')

    blk.fragmented

    match blk.allocate(buf, 3) {
      case Fragmented -> {}
      case _ -> throw 'Block.allocate failed'
    }

    Result.Ok(nil)
  })

  t.ok('Block.allocate with enough space', fn (t) {
    let blk = Block.new
    let buf = Buffer.new('abc')
    let val = match blk.allocate(buf, 3) {
      case Ok(Small(_, v)) -> v
      case _ -> throw 'Block.allocate failed'
    }

    t.equal(val.size, 3)
    t.equal(val.start, 0)
    t.equal(val.end, 3)
    t.true(blk.bytes.starts_with?('abc'))
    t.equal(blk.bytes.size, 3)

    Result.Ok(nil)
  })

  t.ok('Block.allocate with a full block', fn (t) {
    let blk = Block.new
    let buf1 = Buffer.new(ByteArray.filled(with: 1, times: BLOCK_SIZE))
    let buf2 = Buffer.new(ByteArray.from_array([1]))
    let _ = blk.allocate(buf1, BLOCK_SIZE)

    match blk.allocate(buf2, 1) {
      case Full -> {}
      case _ -> throw 'Block.allocate failed'
    }

    Result.Ok(nil)
  })

  t.ok('Block.allocate without enough space', fn (t) {
    let blk = Block.new
    let buf1 = Buffer.new(ByteArray.filled(with: 1, times: BLOCK_SIZE / 2))
    let buf2 = Buffer.new(ByteArray.filled(with: 2, times: BLOCK_SIZE))
    let _ = blk.allocate(buf1, BLOCK_SIZE / 2)

    match blk.allocate(buf2, BLOCK_SIZE) {
      case NotEnoughSpace(n) -> t.equal(n, BLOCK_SIZE / 2)
      case _ -> throw 'Block.allocate failed'
    }

    Result.Ok(nil)
  })

  t.test('Block.add_reusable', fn (t) {
    let blk = Block.new

    t.equal(blk.reusable, 0)
    blk.add_reusable(10)
    t.equal(blk.reusable, 10)
  })

  t.test('Block.remaining', fn (t) {
    let blk = Block.new

    t.equal(blk.remaining, BLOCK_SIZE)

    blk.bytes.push(1)
    t.equal(blk.remaining, BLOCK_SIZE - 1)
  })

  t.test('Block.defragment?', fn (t) {
    let blk = Block.new

    t.false(blk.defragment?)

    blk.reusable = BLOCK_SIZE / 2
    t.true(blk.defragment?)
  })

  t.test('Block.fragmented', fn (t) {
    let blk = Block.new

    blk.fragmented
    t.equal(blk.reusable, -1)
  })

  t.test('Block.fragmented?', fn (t) {
    let blk = Block.new

    blk.fragmented
    t.true(blk.fragmented?)
  })

  t.test('Block.reset', fn (t) {
    let blk = Block.new

    blk.reusable = 10
    blk.bytes.push(1)

    blk.reset
    t.equal(blk.reusable, 0)
    t.equal(blk.bytes.size, 0)
    t.equal(blk.bytes.capacity, BLOCK_SIZE)
  })

  t.ok('Allocator.allocate with a large value', fn (t) {
    let alloc = Allocator.new
    let buf = Buffer.new(ByteArray.filled(with: 1, times: BLOCK_SIZE * 2))
    let res = match alloc.allocate(buf, BLOCK_SIZE * 2) {
      case Ok(Large(v)) -> v
      case _ -> throw 'Allocator.allocate failed'
    }

    t.equal(res.size, BLOCK_SIZE * 2)

    Result.Ok(nil)
  })

  t.ok('Allocator.allocate with a large value and an IO error', fn (t) {
    let alloc = Allocator.new
    let res = match alloc.allocate(ErrorReader(), BLOCK_SIZE * 2) {
      case Error(v) -> v
      case _ -> throw 'Allocator.allocate failed'
    }

    t.equal(res, Error.ConnectionAborted)

    Result.Ok(nil)
  })

  t.ok('Allocator.allocate with a small value', fn (t) {
    let alloc = Allocator.new
    let buf = Buffer.new('abc')
    let res = match alloc.allocate(buf, 3) {
      case Ok(Small(_, v)) -> v
      case _ -> throw 'Allocator.allocate failed'
    }

    t.equal(res.size, 3)
    t.equal(res.to_string, 'abc')

    Result.Ok(nil)
  })

  t.ok('Allocator.allocate with a small value and an IO error', fn (t) {
    let alloc = Allocator.new
    let res = match alloc.allocate(ErrorReader(), 3) {
      case Error(v) -> v
      case _ -> throw 'Allocator.allocate failed'
    }

    t.equal(res, Error.ConnectionAborted)

    Result.Ok(nil)
  })

  t.test('Allocator.allocate with a full block', fn (t) {
    # TODO
  })

  t.test('Allocator.allocate with a fragmented block', fn (t) {
    # TODO
  })

  t.test('Allocator.allocate with a block without enough space', fn (t) {
    # TODO
  })

  t.test('Allocator.add_reusable', fn (t) {
    # TODO
  })

  t.test('Allocator.defragment?', fn (t) {
    # TODO
  })

  t.test('Allocator.defragment', fn (t) {
    # TODO
  })
}
