import kvi.config (Config)
import kvi.logger (Logger)
import std.net.socket (TcpServer)
import std.sync (Future)

type async Listener {
  let @config: Config
  let @logger: Logger
  let @socket: TcpServer

  fn static new(
    config: ref Config,
    logger: Logger,
    socket: uni TcpServer,
  ) -> Listener {
    Listener(config: recover config.clone, logger: logger, socket: socket)
  }

  fn async mut start {
    loop {
      let sock = match @socket.accept {
        case Ok(v) -> v
        case Error(e) -> {
          @logger.warn('failed to accept a new client: ${e}')
          next
        }
      }

      # TODO: parse the message
      # TODO: dispatch to the appropriate shard
    }
  }
}

type Server {
  let @config: Config
  let @logger: Logger

  fn static new(config: Config, logger: Logger) -> Self {
    Server(config: config, logger: logger)
  }

  fn move start -> Result[Nil, String] {
    let port = @config.port.to_int
    let listeners = @config.listeners.to_int

    try @config.ips.iter.try_each(fn (ip) {
      let sock = recover {
        match TcpServer.new(ip, port) {
          case Ok(v) -> v
          case Error(e) -> throw 'failed to bind to ${ip}:${port}: ${e}'
        }
      }

      let mut i = 1

      while i < listeners {
        let sock = recover {
          match sock.try_clone {
            case Ok(v) -> v
            case Error(e) -> throw 'failed to clone a listener socket: ${e}'
          }
        }

        # TODO: retain process?
        let proc = Listener.new(@config, @logger, sock)

        proc.start
        i += 1
      }

      # TODO: retain process?
      let proc = Listener.new(@config.clone, @logger, sock)

      proc.start
      Result.Ok(nil)
    })

    # Wait for any pending log data to be written, otherwise we might stop
    # before doing so.
    match Future.new {
      case (fut, prom) -> {
        @logger.flush(prom)
        fut.get
      }
    }

    Result.Ok(nil)
  }
}
